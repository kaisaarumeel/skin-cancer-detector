# This file is completely generated by AI,
# with the purpose of counting contributions in our repository
# Using Claude 3.5 Sonnet

#!/usr/bin/env python3
import os
import subprocess
import re
from pathlib import Path

# Only process these file types
INCLUDED_EXTENSIONS = {
    ".py",  # Python files
    ".ts",  # TypeScript files
    ".js",  # JavaScript files
    ".css",  # CSS files
    ".yml",  # YAML files
    ".svelte",  # Svelte files
}

# Directories to exclude
EXCLUDED_DIRS = {"venv", "__pycache__", "node_modules", ".git"}


def get_comment_syntax(file_path: str) -> str:
    """Determine the appropriate comment syntax based on file extension."""
    filename = os.path.basename(file_path)
    if filename == "Dockerfile":
        return "#"

    extension = Path(file_path).suffix
    if extension in {".js", ".ts", ".svelte"}:
        return "//"
    elif extension == ".css":
        return "/*"
    elif extension in {".py", ".yml"}:
        return "#"
    return "#"


def get_comment_end(file_path: str) -> str:
    """Get the comment end syntax if needed (for CSS)."""
    if Path(file_path).suffix == ".css":
        return " */"
    return ""


def should_process(file_path: str) -> bool:
    """Check if the file should be processed based on extension."""
    filename = os.path.basename(file_path)
    if filename == "Dockerfile":
        return True

    return Path(file_path).suffix in INCLUDED_EXTENSIONS


def get_git_contributors(file_path: str) -> list:
    """Get unique contributor emails for a file using git blame."""
    try:
        env = os.environ.copy()
        env["LC_ALL"] = "C.UTF-8"
        cmd = ["git", "blame", "--line-porcelain", file_path]
        result = subprocess.run(
            cmd,
            capture_output=True,
            encoding="utf-8",
            errors="replace",
            timeout=5,
            env=env,
        )

        if result.returncode != 0:
            return []

        emails = []
        for line in result.stdout.splitlines():
            if line.startswith("author-mail "):
                email = line.replace("author-mail ", "")
                if email not in emails:
                    emails.append(email)
        return emails
    except Exception as e:
        print(f"Warning: Failed to get contributors for {file_path}: {str(e)}")
        return []


def is_git_tracked(file_path: str) -> bool:
    """Check if the file is tracked by git."""
    try:
        cmd = ["git", "ls-files", "--error-unmatch", file_path]
        result = subprocess.run(cmd, capture_output=True, timeout=2)
        return result.returncode == 0
    except subprocess.TimeoutExpired:
        return False


def process_file(file_path: str) -> None:
    """Process a single file to add contributor information."""
    if not os.path.isfile(file_path) or not should_process(file_path):
        return

    if not is_git_tracked(file_path):
        return

    print(f"Processing {file_path}...")

    # Get contributor emails
    emails = get_git_contributors(file_path)
    if not emails:
        return

    # Get appropriate comment syntax
    comment_start = get_comment_syntax(file_path)
    comment_end = get_comment_end(file_path)

    try:
        # Read original content
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Prepare contributor section
        if comment_end:  # For CSS files
            contributor_lines = [
                f"{comment_start} Contributors:",
                *[f" * Contributor: {email}" for email in emails],
                f"{comment_end}",
                "",
            ]
        else:  # For other files
            contributor_lines = [
                f"{comment_start} Contributors:",
                *[f"{comment_start} * Contributor: {email}" for email in emails],
                "",
            ]

        contributor_text = "\n".join(contributor_lines)

        # Special handling for different file types
        if file_path.endswith(".svelte"):
            # Find the first <script> tag
            script_match = re.search(r"(<script[^>]*>)", content)
            if script_match:
                # Insert contributor text after the script tag
                start = script_match.end()
                new_content = (
                    content[:start] + "\n" + contributor_text + content[start:]
                )
            else:
                # If no script tag found, add at the top
                new_content = contributor_text + content
        else:
            # For all other files, add at the top
            new_content = contributor_text + content

        # Write new content
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(new_content)

    except Exception as e:
        print(f"Error processing {file_path}: {str(e)}")


def main():
    """Main function to process all files in the repository."""
    print("Processing files...")

    # Start from current directory
    for root, dirs, files in os.walk("."):
        # Remove excluded directories
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS and not d.startswith(".")]

        # Process each file
        for file in files:
            if not file.startswith("."):
                file_path = os.path.join(root, file)
                try:
                    process_file(file_path)
                except Exception as e:
                    print(f"Error processing {file_path}: {str(e)}")

    print("Finished processing files!")


if __name__ == "__main__":
    main()
